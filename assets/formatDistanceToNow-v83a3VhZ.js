import{c as I}from"./index-Cz0ZLwjf.js";import{c as S}from"./constructNow-CztL-i6M.js";import{t as a,e as X,g as p,m as y,a as M,b as x}from"./en-US-ktNFwBEl.js";/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const A=I("TrendingUp",[["polyline",{points:"22 7 13.5 15.5 8.5 10.5 2 17",key:"126l90"}],["polyline",{points:"16 7 22 7 22 13",key:"kwv8wd"}]]);function D(n,t){const s=a(n),r=a(t),e=s.getTime()-r.getTime();return e<0?-1:e>0?1:e}function O(n,t){const s=a(n),r=a(t),e=s.getFullYear()-r.getFullYear(),c=s.getMonth()-r.getMonth();return e*12+c}function _(n){return t=>{const r=(n?Math[n]:Math.trunc)(t);return r===0?0:r}}function Y(n,t){return+a(n)-+a(t)}function w(n){const t=a(n);return t.setHours(23,59,59,999),t}function b(n){const t=a(n),s=t.getMonth();return t.setFullYear(t.getFullYear(),s+1,0),t.setHours(23,59,59,999),t}function N(n){const t=a(n);return+w(t)==+b(t)}function R(n,t){const s=a(n),r=a(t),e=D(s,r),c=Math.abs(O(s,r));let f;if(c<1)f=0;else{s.getMonth()===1&&s.getDate()>27&&s.setDate(30),s.setMonth(s.getMonth()-e*c);let o=D(s,r)===-e;N(a(n))&&c===1&&D(n,r)===1&&(o=!1),f=e*(c-Number(o))}return f===0?0:f}function F(n,t,s){const r=Y(n,t)/1e3;return _(s?.roundingMethod)(r)}function L(n,t,s){const r=x(),e=s?.locale??r.locale??X,c=2520,f=D(n,t);if(isNaN(f))throw new RangeError("Invalid time value");const o=Object.assign({},s,{addSuffix:s?.addSuffix,comparison:f});let m,h;f>0?(m=a(t),h=a(n)):(m=a(n),h=a(t));const l=F(h,m),T=(p(h)-p(m))/1e3,i=Math.round((l-T)/60);let d;if(i<2)return s?.includeSeconds?l<5?e.formatDistance("lessThanXSeconds",5,o):l<10?e.formatDistance("lessThanXSeconds",10,o):l<20?e.formatDistance("lessThanXSeconds",20,o):l<40?e.formatDistance("halfAMinute",0,o):l<60?e.formatDistance("lessThanXMinutes",1,o):e.formatDistance("xMinutes",1,o):i===0?e.formatDistance("lessThanXMinutes",1,o):e.formatDistance("xMinutes",i,o);if(i<45)return e.formatDistance("xMinutes",i,o);if(i<90)return e.formatDistance("aboutXHours",1,o);if(i<y){const u=Math.round(i/60);return e.formatDistance("aboutXHours",u,o)}else{if(i<c)return e.formatDistance("xDays",1,o);if(i<M){const u=Math.round(i/y);return e.formatDistance("xDays",u,o)}else if(i<M*2)return d=Math.round(i/M),e.formatDistance("aboutXMonths",d,o)}if(d=R(h,m),d<12){const u=Math.round(i/M);return e.formatDistance("xMonths",u,o)}else{const u=d%12,g=Math.trunc(d/12);return u<3?e.formatDistance("aboutXYears",g,o):u<9?e.formatDistance("overXYears",g,o):e.formatDistance("almostXYears",g+1,o)}}function U(n,t){return L(n,S(n),t)}export{A as T,U as f};
